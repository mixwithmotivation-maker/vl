library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL; -- Use the modern standard library

entity myfifo_16x8 is
    Port ( 
        -- Inputs
        clk     : in  STD_LOGIC; -- System Clock
        rst     : in  STD_LOGIC; -- Asynchronous Reset (active high)
        clk_en  : in  STD_LOGIC; -- Clock Enable (was 'en' in old code)
        datain  : in  STD_LOGIC_VECTOR(7 downto 0); -- Data to write
        wr_rd   : in  STD_LOGIC; -- Write/Read control (1=Write, 0=Read) (was 'W')

        -- Outputs
        dataout   : out STD_LOGIC_VECTOR(7 downto 0); -- Data read from FIFO
        fifo_full : out STD_LOGIC; -- '1' when FIFO is full
        fifo_empty: out STD_LOGIC  -- '1' when FIFO is empty
    );
end myfifo_16x8;

architecture Behavioral of myfifo_16x8 is

    -- 1. Define the memory array
    -- This creates 16 locations (0 to 15), each 8 bits wide
    type t_fifo_mem is array (0 to 15) of STD_LOGIC_VECTOR(7 downto 0);
    signal mem : t_fifo_mem;

    -- 2. Define pointers. Use 'unsigned' for easy arithmetic
    signal wptr : unsigned(3 downto 0); -- Write pointer
    signal rptr : unsigned(3 downto 0); -- Read pointer

    -- 3. Define a counter to track how many items are in the FIFO
    -- This is the *best* way to handle full/empty logic
    signal item_counter : integer range 0 to 16; -- Can hold 0 to 16 items

    -- Internal signal for clock divider (optional, but in your original)
    signal clk_div : unsigned(21 downto 0);
    signal slow_clk : STD_LOGIC;

begin

    -- Optional Clock Divider (from your original code)
    -- This slows down the FIFO logic for simulation/testing
    process(clk, rst)
    begin
        if rst = '1' then
            clk_div <= (others => '0');
        elsif rising_edge(clk) then
            clk_div <= clk_div + 1;
        end if;
    end process;
    
    -- Use the 21st bit as the slow clock
    -- NOTE: For simulation, you might want a faster bit, e.g. clk_div(10)
    slow_clk <= clk_div(21);


    -- Main FIFO Logic: Pointers and Counter
    process(slow_clk, rst)
    begin
        if rst = '1' then
            -- Reset all pointers and counter
            wptr <= (others => '0');
            rptr <= (others => '0');
            item_counter <= 0;
            dataout <= (others => '0'); -- Clear data output on reset

        elsif rising_edge(slow_clk) then
            -- Only run if the clock enable is active
            if clk_en = '1' then

                -- Case 1: WRITE operation (and not full)
                if (wr_rd = '1' and item_counter < 16) then
                    
                    -- Write data to the memory at the write pointer
                    mem(to_integer(wptr)) <= datain;
                    
                    -- Increment the write pointer (it wraps automatically)
                    wptr <= wptr + 1;
                    
                    -- Increment the item counter
                    item_counter <= item_counter + 1;

                -- Case 2: READ operation (and not empty)
                elsif (wr_rd = '0' and item_counter > 0) then
                    
                    -- Read data from memory at the read pointer
                    dataout <= mem(to_integer(rptr));
                    
                    -- Increment the read pointer (it wraps automatically)
                    rptr <= rptr + 1;
                    
                    -- Decrement the item counter
                    item_counter <= item_counter - 1;
                
                -- Case 3: No operation (full, empty, or idle)
                else
                    -- Do nothing, hold current state
                end if;

            end if; -- end clk_en
        end if; -- end clk/rst
    end process;

    -- Combinational logic for Full/Empty flags
    -- This logic is always running
    fifo_full  <= '1' when item_counter = 16 else '0';
    fifo_empty <= '1' when item_counter = 0  else '0';

end Behavioral;
___________________________________________________________________________________________
-- testbench: tb_myfifo 
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity tb_myfifo is
end tb_myfifo;

architecture behavior of tb_myfifo is 
 
    -- Component Declaration for the FIFO
    component myfifo_16x8
    Port ( 
        clk     : in  STD_LOGIC;
        rst     : in  STD_LOGIC;
        clk_en  : in  STD_LOGIC;
        datain  : in  STD_LOGIC_VECTOR(7 downto 0);
        wr_rd   : in  STD_LOGIC;
        dataout   : out STD_LOGIC_VECTOR(7 downto 0);
        fifo_full : out STD_LOGIC;
        fifo_empty: out STD_LOGIC
    );
    end component;
    
   --Inputs
   signal clk     : STD_LOGIC := '0';
   signal rst     : STD_LOGIC := '0';
   signal clk_en  : STD_LOGIC := '0';
   signal datain  : STD_LOGIC_VECTOR(7 downto 0) := (others => '0');
   signal wr_rd   : STD_LOGIC := '0';

 	--Outputs
   signal dataout   : STD_LOGIC_VECTOR(7 downto 0);
   signal fifo_full : STD_LOGIC;
   signal fifo_empty: STD_LOGIC;

   -- Clock period definition
   -- We use 25ns main clock to easily create the 250ns slow clock
   constant clk_period : time := 25 ns;
 
begin
 
	-- Instantiate the Unit Under Test (UUT)
    uut: myfifo_16x8 
        Port map (
            clk => clk,
            rst => rst,
            clk_en => clk_en,
            datain => datain,
            wr_rd => wr_rd,
            dataout => dataout,
            fifo_full => fifo_full,
            fifo_empty => fifo_empty
        );

   -- Clock process definition
   clk_process :process
   begin
		clk <= '0';
		wait for clk_period/2;
		clk <= '1';
		wait for clk_period/2;
   end process;
 

   -- Stimulus process
   stim_proc: process
   begin		
      -- 1. Initialize and Reset
      rst <= '1';
      clk_en <= '1'; -- 'en' is high in the waveform
      wait for 100 ns;	
      rst <= '0';
      
      -- Wait until 250ns, matching the waveform
      wait for 150 ns; -- (100 + 150 = 250ns)

      -- 2. Write 'h11' (at 250ns)
      wr_rd <= '1';
      datain <= x"11";
      wait for 250 ns; -- Wait for one slow_clk period

      -- 3. Write 'h22' (at 500ns)
      wr_rd <= '1';
      datain <= x"22";
      wait for 250 ns;
      
      -- 4. Write 'h33' (at 750ns)
      wr_rd <= '1';
      datain <= x"33";
      wait for 250 ns;

      -- 5. Switch to READ (at 1000ns)
      wr_rd <= '0';
      datain <= x"44"; -- This value won't be written
      wait for 250 ns;

      -- 6. Read 'h11' (at 1250ns)
      -- The 'dataout' signal will now show x"11"
      wait for 250 ns;

      -- 7. Read 'h22' (at 1500ns)
      -- The 'dataout' signal will now show x"22"
      wait for 250 ns;
      
      -- 8. Read 'h33' (at 1750ns)
      -- The 'dataout' signal will now show x"33"
      wait for 250 ns;
      
      -- 9. Read again (at 2000ns)
      -- FIFO should now be empty
      
      wait; -- End simulation
   end process;

end;
