library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity shift_reg is
Port (
clk  : in  STD_LOGIC;
rst  : in  STD_LOGIC;
pi   : in  STD_LOGIC_VECTOR(3 downto 0);
si   : in  STD_LOGIC;
load : in  STD_LOGIC;
mode : in  STD_LOGIC_VECTOR(1 downto 0);
so   : out STD_LOGIC;
po   : out STD_LOGIC_VECTOR(3 downto 0)
);
end shift_reg;

architecture Behavioral of shift_reg is
signal counter : integer range 0 to 3 := 0;
signal clkout  : STD_LOGIC := '0';
signal temp    : STD_LOGIC_VECTOR(3 downto 0) := (others => '0');
begin
process(clk, rst)
begin
if rst = '1' then
counter <= 0;
clkout  <= '0';
elsif rising_edge(clk) then
if counter = 3 then
counter <= 0;
clkout  <= not clkout;
else
counter <= counter + 1;
end if;
end if;
end process;

process(clkout, rst)
begin
if rst = '1' then
temp <= (others => '0');
po   <= (others => '0');
so   <= '0';
elsif rising_edge(clkout) then
case mode is
when "00" =>
temp <= pi;
po   <= pi;
so   <= temp(0);
when "01" =>
temp(0) <= temp(1);
temp(1) <= temp(2);
temp(2) <= temp(3);
temp(3) <= si;
po      <= temp;
so      <= temp(0);
when "10" =>
if load = '1' then
temp <= pi;
else
temp(0) <= temp(1);
temp(1) <= temp(2);
temp(2) <= temp(3);
temp(3) <= si;
end if;
po <= temp;
so <= temp(0);
when others =>
null;
end case;
end if;
end process;
end Behavioral;
_________________________________________________________________________________________
--testbench
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity tb_shift_reg is
end tb_shift_reg;

architecture sim of tb_shift_reg is
constant clk_period : time := 10 ns;
signal clk   : STD_LOGIC := '0';
signal rst   : STD_LOGIC := '0';
signal pi    : STD_LOGIC_VECTOR(3 downto 0) := (others => '0');
signal si    : STD_LOGIC := '0';
signal load  : STD_LOGIC := '0';
signal mode  : STD_LOGIC_VECTOR(1 downto 0) := (others => '0');
signal po    : STD_LOGIC_VECTOR(3 downto 0);
signal so    : STD_LOGIC;
begin
uut : entity work.shift_reg
port map (
clk  => clk,
rst  => rst,
pi   => pi,
si   => si,
load => load,
mode => mode,
so   => so,
po   => po
);

clk_process : process
begin
clk <= '0';
wait for clk_period/2;
clk <= '1';
wait for clk_period/2;
end process;

stim_proc : process
begin
rst <= '1';
wait for 20 ns;
rst <= '0';

mode <= "00";  pi <= "1001";
wait for 40 ns;

mode <= "01";  si <= '1';
wait for 40 ns;
si <= '0';
wait for 40 ns;

mode <= "10";  load <= '1';  pi <= "1010";
wait for 40 ns;
load <= '0';
wait for 100 ns;

wait;
end process;
end sim;
